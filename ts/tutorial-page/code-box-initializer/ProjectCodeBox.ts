import CodeBox from "./CodeBox";
import CodeBoxCode from "./CodeBoxCode";
import CodeButton from "./CodeButton";
import CollapsibleContainer from "./CollapsibleContainer";
import CollapsibleContainerFactory from "./CollapsibleContainerFactory";
import FileButton from "./FileButton";
import MultiProjectCodeButton from "./MultiProjectCodeButton";
import ProjectCodeButton from "./ProjectCodeButton";
import ProjectDownloadFileButton from "./ProjectDownloadFileButton";
import ProjectNoDownloadFileButton from "./ProjectNoDownloadFileButton";
import SVGIconElementCreator from "./SVGIconElementCreator";
import TreeNode from "./TreeNode";

/**
 * Represents project code box.
 */
class ProjectCodeBox extends CodeBox {
    /** CSS modifier class for root element of code box. */
    private static readonly CSS_CODE_BOX_MODIFIER_CLASS = "code-box--project";
    /** CSS class for code box panel. */
    private static readonly CSS_PANEL_CLASS = "code-box-project-panel";
    /** CSS modifier class to be added to code box panel when it should be opened. */
    private static readonly CSS_PANEL_OPENED_MODIFIER_CLASS = "code-box-project-panel--opened";
    /** CSS class for content container for code box panel. */
    private static readonly CSS_PANEL_CONTENT_CLASS = "code-box-project-panel__content";
    /** CSS class for toggle button of code box panel. */
    private static readonly CSS_PANEL_TOGGLE_BUTTON_CLASS = "code-box-project-panel__toggle-button";
    /** CSS modifier class to be added to toggle button of code box panel when it should be opened. */
    private static readonly CSS_PANEL_TOGGLE_BUTTON_OPENED_MODIFIER_CLASS = "code-box-project-panel__toggle-button--opened";
    /** CSS class for code box panel headings. */
    private static readonly CSS_PANEL_HEADING_CLASS = "code-box-project-panel__heading";
    /** CSS class for code obx panel horizontal rule. */
    private static readonly CSS_PANEL_HORIZONTAL_RULE_CLASS = "code-box-project-panel__horizontal-rule";

    /** Name of icon for code box panel toggle button. */
    private static readonly PANEL_TOGGLE_BUTTON_ICON_NAME = "double-arrow-right";

    /** Text of code box panel toggle button. */
    private static readonly PANEL_TOGGLE_BUTTON_TEXT = "Otevří/Zavřít boční panel";

    /** Stores project IDs of all created code boxes. */
    private static readonly occupiedProjectIds : Map<string, boolean> = new Map();

    /** Unique identifier of code box. */
    private projectId : string;

    /** Root folder (project) collapsible container. */
    private rootFolder : CollapsibleContainer;
    /** Folder collapsible containers by folder paths. */
    private folders : Map<string, CollapsibleContainer>;
    /** Default java package collapsible container. */
    private defaultJavaPackage : CollapsibleContainer | null;
    /** Java package collapsible containers by java package names. */
    private javaPackages : Map<string, CollapsibleContainer>;

    /** Path of to folder that is used for java packages. */
    private javaPackagesFolderPath: string | null;

    /** Stores folder paths for folders that were automatically generated during initialization. */
    private autoGeneratedFolders : Map<string, boolean>;
    /** Stores paths for initialized files (codes and files). Used when initialiazing code box to prevent duplicate codes and files. */
    private usedFilePaths: Map<string, boolean>;
    /** Stores java package paths for initialized files (codes) in following format javaPackage.fileName. Used when initializing code box to prevent duplicate codes. */
    private usedJavaPackagePaths: Map<string, boolean>;

    /** Panel element of code box. */
    private panelElement : HTMLElement;
    /** Content element of code box panel. */
    private panelContentElement : HTMLElement;
    /** Toggle button of code box panel. */
    private panelToggleButton : HTMLButtonElement;

    /**
     * Creates new project code box.
     * @param codeBoxElement Code box element.
     * @param parentCodeBox Parent code box element from which should be inherited folders and files.
     */
    constructor(codeBoxElement: HTMLElement, parentCodeBox: ProjectCodeBox | null = null) {
        super(codeBoxElement, true);

        this.projectId = this.getProjectIdFromDataAttribute();

        this.folders = new Map();
        this.javaPackages = new Map();
        this.defaultJavaPackage = null;

        this.javaPackagesFolderPath = null;

        this.autoGeneratedFolders = new Map();
        this.usedFilePaths = new Map();
        this.usedJavaPackagePaths = new Map();

        codeBoxElement.classList.add(ProjectCodeBox.CSS_CODE_BOX_MODIFIER_CLASS);

        // create code box panel
        this.panelElement = document.createElement("div");
        this.panelElement.classList.add(ProjectCodeBox.CSS_PANEL_CLASS);
        codeBoxElement.appendChild(this.panelElement);

        // create content element of code box panel
        this.panelContentElement = document.createElement("div");
        this.panelContentElement.classList.add(ProjectCodeBox.CSS_PANEL_CONTENT_CLASS);
        this.panelElement.appendChild(this.panelContentElement);

        // create toggle button of code box panel
        this.panelToggleButton = this.createPanelToggleButton();
        this.panelToggleButton.addEventListener("click", () => this.onPanelToggleButtonClick());

        // create folder structure heading
        const folderStructureHeading = document.createElement("h3");
        folderStructureHeading.classList.add(ProjectCodeBox.CSS_PANEL_HEADING_CLASS);
        folderStructureHeading.innerText = "Adresářová struktura";
        this.panelContentElement.appendChild(folderStructureHeading);

        // create folder structure based on parent code box or from configuration element
        if (parentCodeBox) {
            this.rootFolder = CollapsibleContainerFactory.createProjectRoot(parentCodeBox.getProjectName(), this.projectId);
            this.rootFolder.appendToElement(this.panelContentElement);
            this.createFoldersStructureFromFoldersTree(parentCodeBox.getInitFolderStructure(), this.rootFolder);
            // inherit java packages folder path
            this.javaPackagesFolderPath = parentCodeBox.javaPackagesFolderPath;
        } else {
            this.rootFolder = CollapsibleContainerFactory.createProjectRoot(codeBoxElement.dataset.projectName || "unnamed", this.projectId);
            this.rootFolder.appendToElement(this.panelContentElement);
            this.createFoldersStructure(this.rootFolder);
        }

        // create horizontal rule in code box panel
        const horizontalRule = document.createElement("hr");
        horizontalRule.classList.add(ProjectCodeBox.CSS_PANEL_HORIZONTAL_RULE_CLASS);
        this.panelContentElement.appendChild(horizontalRule);

        // create java packages heading
        const javaPackagesHeading = document.createElement("h3");
        javaPackagesHeading.classList.add(ProjectCodeBox.CSS_PANEL_HEADING_CLASS);
        javaPackagesHeading.innerText = "Java balíčky";
        this.panelContentElement.appendChild(javaPackagesHeading);

        // copy all code and file elements from parent code box
        if (parentCodeBox) {
            for (let code of parentCodeBox.codes) {
                const codeElement = code.cloneCodeElement();
                codeBoxElement.appendChild(codeElement);
            }
            const fileElements = parentCodeBox.getFileElements();
            fileElements.forEach(fileElement => {
                codeBoxElement.appendChild(fileElement.cloneNode(true));
            });
        }

        // process commands before initialization of code box
        this.processCommands();

        this.init();

        // sort folders, files and java packages in code box panel
        this.sortJavaPackages();
        this.sortFolders();
        this.sortFileButtons();

        // if there are no files (codes) in java packages, java packages section is hidden
        if (this.javaPackages.size === 0 && !this.defaultJavaPackage) {
            horizontalRule.remove();
            javaPackagesHeading.remove();
        }

        // process commands after initialization of code box
        this.processCommandsAfterInit();

        this.removeConfigurationElements();
    }

    /**
     * Returns project name of code box.
     * @returns Project name.
     */
    public getProjectName() : string {
        return this.rootFolder.name;
    }

    /**
     * Returns project ID of code box.
     * @returns Project ID.
     */
    public getProjectId() {
        return this.projectId;
    }

    /**
     * Called when toggle button of code box panel is clicked.
     */
    private onPanelToggleButtonClick() : void {
        this.panelToggleButton.classList.toggle(ProjectCodeBox.CSS_PANEL_TOGGLE_BUTTON_OPENED_MODIFIER_CLASS);
        this.panelElement.classList.toggle(ProjectCodeBox.CSS_PANEL_OPENED_MODIFIER_CLASS);
    }

    protected onDisplayedCodeChanged(): void {
        this.panelToggleButton.classList.remove(ProjectCodeBox.CSS_PANEL_TOGGLE_BUTTON_OPENED_MODIFIER_CLASS);
        this.panelElement.classList.remove(ProjectCodeBox.CSS_PANEL_OPENED_MODIFIER_CLASS);
    }

    protected validateCodeElement(codeElement: HTMLElement): boolean {
        let isValid = true;

        let filePath;
        // determine file path on data-code and data-folder or data-java-package attribute
        if (this.javaPackagesFolderPath !== null && codeElement.dataset.folder === undefined && codeElement.dataset.javaPackage !== undefined) {
            const javaPackage = codeElement.dataset.javaPackage?.trim();
            if (javaPackage) {
                filePath = this.javaPackagesFolderPath + "/" + javaPackage.replace(/\./g, "/") + "/" + (codeElement.dataset.code || "unnamed");
            } else {
                filePath = this.javaPackagesFolderPath + "/" + (codeElement.dataset.code || "unnamed");
            }
        } else {
            let pathArr: string[];
            pathArr = codeElement.dataset.folder?.split("/") || [];
            pathArr = pathArr.filter(folderName => folderName.trim().length > 0);
            pathArr.push(codeElement.dataset.code || "unnamed");
            filePath = pathArr.join("/");
        }

        // if file path is already used for different code/file element
        if (this.usedFilePaths.has(filePath)) {
            isValid = false;
        } else {
            this.usedFilePaths.set(filePath, true);
        }

        // potentionally validate data-java-package attribute
        if (codeElement.dataset.javaPackage !== undefined) {
            // create java package path in format javaPackage.fileName
            let javaPackagePath = codeElement.dataset.javaPackage.trim();
            if (javaPackagePath.length > 0) {
                javaPackagePath += ".";
            }
            javaPackagePath += codeElement.dataset.code || "unnamed";

            // if java package path is already used by different code element
            if (this.usedJavaPackagePaths.has(javaPackagePath)) {
                isValid = false;
            } else {
                this.usedJavaPackagePaths.set(javaPackagePath, true);
            }
        }
        
        return isValid;
    }

    protected validateFileElement(fileElement: HTMLElement): boolean {
        let isValid = true;

        // determine file path based on data-file and data-folder attributes
        let pathArr: string[];
        pathArr = fileElement.dataset.folder?.split("/") || [];
        pathArr = pathArr.filter(folderName => folderName.trim().length > 0);
        pathArr.push(fileElement.dataset.file || "unnamed");
        let filePath = pathArr.join("/");

        // if file path is already used for different code/file element
        if (this.usedFilePaths.has(filePath)) {
            isValid = false;
        } else {
            this.usedFilePaths.set(filePath, true);
        }

        return isValid;
    }

    protected createCodeButton(codeBoxCode: CodeBoxCode, codeElementDataset: DOMStringMap): CodeButton {
        let folderPath = codeElementDataset.folder;
        const javaPackage = codeElementDataset.javaPackage?.trim();
        const fileName = codeElementDataset.code;

        let javaPackageCollapsible;
        // potentionally get/create java package collapsible container
        if (javaPackage !== undefined) {
            // get/create java package collapsible container
            if (javaPackage.length > 0) {
                javaPackageCollapsible = this.javaPackages.get(javaPackage);
                if (!javaPackageCollapsible) {
                    javaPackageCollapsible = CollapsibleContainerFactory.createJavaPackage(javaPackage, this.projectId);
                    javaPackageCollapsible.appendToElement(this.panelContentElement);
                    this.javaPackages.set(javaPackage, javaPackageCollapsible);
                }
            } else {
                javaPackageCollapsible = this.defaultJavaPackage;
                if (!javaPackageCollapsible) {
                    javaPackageCollapsible = CollapsibleContainerFactory.createDefaultJavaPackage(this.projectId);
                    javaPackageCollapsible.appendToElement(this.panelContentElement);
                    this.defaultJavaPackage = javaPackageCollapsible;
                }
            }
            
            // if java package collapsible container should be opened at start
            if (codeElementDataset.javaPackageOpened !== undefined) {
                javaPackageCollapsible.setAsOpenedOnInit();
            }

            // potentionally create folder collapsible containers in java packages folder
            if (folderPath === undefined && this.javaPackagesFolderPath) {
                const folderNames = javaPackage.split(".");

                folderPath = this.javaPackagesFolderPath;
                let previousFolder = this.folders.get(folderPath);
                if (previousFolder) {
                    for (let folderName of folderNames) {
                        if (folderName.trim().length === 0) continue;
                        folderPath += `/${folderName.trim()}`;
                        
                        let folder = this.folders.get(folderPath);
                        if (!folder) {
                            folder = CollapsibleContainerFactory.createFolder(folderName.trim(), folderPath, this.projectId);
                            folder.appendToElement(previousFolder.collapsibleElement);
                            this.folders.set(folderPath, folder);

                            this.autoGeneratedFolders.set(folderPath, true);
                        }

                        previousFolder = folder;
                    }
                }
            }
        }

        let folderCollapsible;
        // get folder collapsible
        if (folderPath) {
            folderCollapsible = this.folders.get(folderPath);
            if (!folderCollapsible) folderCollapsible = this.rootFolder;
        } else {
            folderCollapsible = this.rootFolder;
        }

        // create multi or project code button
        if (javaPackageCollapsible) {
            return new MultiProjectCodeButton(fileName || "unnamed", [folderCollapsible.collapsibleElement, javaPackageCollapsible.collapsibleElement], codeBoxCode);
        } else {
            return new ProjectCodeButton(fileName || "unnamed", folderCollapsible.collapsibleElement, codeBoxCode);
        }
    }

    protected createFileButton(fileName: string, fileElementDataset: DOMStringMap): FileButton {
        let folderPath = fileElementDataset.folder;

        let folderCollapsible;
        // get folder collapsible based on folder path
        if (folderPath) {
            folderCollapsible = this.folders.get(folderPath);
            if (!folderCollapsible) folderCollapsible = this.rootFolder;
        } else {
            folderCollapsible = this.rootFolder;
        }

        // create file button (with or without download link)
        if (fileElementDataset.file) {
            return new ProjectDownloadFileButton(fileName || "unnamed", fileElementDataset.file, folderCollapsible.collapsibleElement);
        } else {
            return new ProjectNoDownloadFileButton(fileName || "unnamed", folderCollapsible.collapsibleElement);
        }
    }

    /**
     * Processes commands before initialization of code box.
     */
    private processCommands() : void {
        // get command elements container
        const commandElementsContainer = this.codeBoxElement.querySelector("[data-project-commands]");
        if (!commandElementsContainer) return;

        // for each command element in command elements container
        for (let i = 0; i < commandElementsContainer.children.length; i++) {
            const commandElement = commandElementsContainer.children[i] as HTMLElement;

            // REMOVE FOLDER COMMAND
            if (commandElement.dataset.commandRemoveFolder !== undefined) {
                const folderPath = commandElement.innerText.trim();

                let querySelector: string;
                if (this.javaPackagesFolderPath !== null && (folderPath.startsWith(this.javaPackagesFolderPath) || this.javaPackagesFolderPath.startsWith(folderPath))) {
                    querySelector = `[data-folder^="${folderPath}"], [data-java-package]`;
                } else {
                    querySelector = `[data-folder^="${folderPath}"]`;
                }
                const codeElements = this.codeBoxElement.querySelectorAll(querySelector);
                codeElements.forEach(codeElement => {
                    let codeElementFolderPath = (codeElement as HTMLElement).dataset.folder;
                    if (codeElementFolderPath === undefined) {
                        let javaPackage = (codeElement as HTMLElement).dataset.javaPackage;
                        if (javaPackage === undefined) return;

                        if (this.javaPackagesFolderPath) {
                            codeElementFolderPath = this.javaPackagesFolderPath + "/" + javaPackage.replace(/\./g, "/");
                        } else {
                            codeElementFolderPath = "";
                        }
                    }

                    // if code is located in different folder that just starts with folderPath
                    if (codeElementFolderPath.length > folderPath.length && codeElementFolderPath.charAt(folderPath.length) !== "/") return;
                    if (codeElementFolderPath.length < folderPath.length) return;
                    
                    codeElement.remove();
                });

                const folderPathsToDelete: string[] = [];
                this.folders.forEach((_, path) => {
                    if (path.startsWith(folderPath)) {
                        if (path.length > folderPath.length && path.charAt(folderPath.length) !== "/") return;
                        folderPathsToDelete.push(path);
                    }
                });

                for (let path of folderPathsToDelete) {
                    const folderCollapsible = this.folders.get(path);
                    folderCollapsible?.detachFromElement();
                    this.folders.delete(path);
                }

                continue;
            }

            // REMOVE FILE COMMAND
            if (commandElement.dataset.commandRemoveFile !== undefined) {
                const filePath = commandElement.innerText.trim();

                let querySelector: string;
                if (!filePath.includes("/")) {
                    querySelector = `[data-code="${filePath}"]`;
                } else if (this.javaPackagesFolderPath !== null && filePath.startsWith(this.javaPackagesFolderPath)) {
                    querySelector = `[data-code][data-folder^="${filePath}"], [data-code][data-java-package]`;
                } else {
                    querySelector = `[data-code][data-folder^="${filePath}"]`;
                }
                const codeElements = this.codeBoxElement.querySelectorAll(querySelector);

                codeElements.forEach(codeElement => {
                    let codeElementFilePath;
                    if ((codeElement as HTMLElement).dataset.folder === undefined && (codeElement as HTMLElement).dataset.javaPackage !== undefined) {
                        let javaPackage = (codeElement as HTMLElement).dataset.javaPackage;
                        if (javaPackage === undefined) return;

                        if (this.javaPackagesFolderPath) {
                            if (javaPackage.length > 0) {
                                codeElementFilePath = this.javaPackagesFolderPath + "/" + javaPackage.replace(/\./g, "/") + "/" + ((codeElement as HTMLElement).dataset.code || "unnamed");
                            } else {
                                codeElementFilePath = this.javaPackagesFolderPath + "/" + ((codeElement as HTMLElement).dataset.code || "unnamed");
                            }
                        } else {
                            codeElementFilePath = ((codeElement as HTMLElement).dataset.code || "unnamed");
                        }
                    } else {
                        if ((codeElement as HTMLElement).dataset.folder) {
                            codeElementFilePath = (codeElement as HTMLElement).dataset.folder + "/" + ((codeElement as HTMLElement).dataset.code || "unnamed");
                        } else {
                            codeElementFilePath = ((codeElement as HTMLElement).dataset.code || "unnamed");
                        }
                    }

                    if (codeElementFilePath === filePath) {
                        codeElement.remove();
                    }
                });

                const fileElements = this.getFileElementsByPath(filePath);
                for (let fileElement of fileElements) {
                    fileElement.remove();
                }

                continue;
            }

            // RENAME FOLDER COMMAND
            if (commandElement.dataset.commandRenameFolder !== undefined) {
                const folderPath = commandElement.innerText.trim();
                const newFolderName = commandElement.dataset.commandRenameFolder.trim();
                let startIndex: number;
                if (folderPath.includes("/")) {
                    startIndex = folderPath.lastIndexOf("/") + 1;
                } else {
                    startIndex = 0;
                }

                if (newFolderName.length === 0) continue;

                if (this.javaPackagesFolderPath !== null && this.javaPackagesFolderPath.startsWith(folderPath)) {
                    let endIndex = this.javaPackagesFolderPath.indexOf("/", startIndex + 1);
                    if (endIndex === -1) {
                        endIndex = this.javaPackagesFolderPath.length;
                    }

                    this.javaPackagesFolderPath = this.javaPackagesFolderPath.substring(0, startIndex) + newFolderName + this.javaPackagesFolderPath.substring(endIndex, this.javaPackagesFolderPath.length);
                }

                const folderPathsToRename: {oldPath: string, newPath: string}[] = [];
                this.folders.forEach((_, path) => {
                    if (!path.startsWith(folderPath)) return;
                    if (path.length > folderPath.length && path.charAt(folderPath.length) !== "/") return;

                    let endIndex = path.indexOf("/", startIndex + 1);
                    if (endIndex === -1) {
                        endIndex = path.length;
                    }

                    folderPathsToRename.push({
                        oldPath: path,
                        newPath: path.substring(0, startIndex) + newFolderName + path.substring(endIndex, path.length)
                    });
                });

                for (let folder of folderPathsToRename) {
                    const folderCollapsible = this.folders.get(folder.oldPath);
                    this.folders.delete(folder.oldPath);
                    if (folderCollapsible) {
                        if (folder.oldPath === folderPath) {
                            folderCollapsible.name = newFolderName;
                        }
                        this.folders.set(folder.newPath, folderCollapsible);
                    }
                }

                const codeElements = this.codeBoxElement.querySelectorAll(`[data-folder^="${folderPath}"]`);
                codeElements.forEach(codeElement => {
                    let path = (codeElement as HTMLElement).dataset.folder;
                    if (path === undefined) return;
                    if (!path.startsWith(folderPath)) return;
                    if (path.length > folderPath.length && path.charAt(folderPath.length) !== "/") return;

                    let endIndex = path.indexOf("/", startIndex + 1);
                    if (endIndex === -1) {
                        endIndex = path.length;
                    }

                    (codeElement as HTMLElement).dataset.folder = path.substring(0, startIndex) + newFolderName + path.substring(endIndex, path.length);
                });

                continue;
            }

            // RENAME FILE COMMAND
            if (commandElement.dataset.commandRenameFile !== undefined) {
                const filePath = commandElement.innerText.trim();
                const newName = commandElement.dataset.commandRenameFile.trim();
                if (newName.length === 0) continue;

                const codeElements = this.getCodeElementsByPath(filePath);
                const fileElements = this.getFileElementsByPath(filePath);

                codeElements.forEach(codeElement => {
                    (codeElement as HTMLElement).dataset.code = newName;
                });
                for (let fileElement of fileElements) {
                    (fileElement as HTMLElement).innerText = newName;
                }

                continue;
            }

            // OPEN FOLDER COMMAND
            if (commandElement.dataset.commandOpenFolder !== undefined) {
                const folderPath = commandElement.innerText.trim();

                const folder = this.folders.get(folderPath);
                if (!folder) continue;

                folder.setAsOpenedOnInit();

                continue;
            }

            // OPEN FOLDER TO ROOT COMMAND
            if (commandElement.dataset.commandOpenFolderToRoot !== undefined) {
                let folderPath = commandElement.innerText.trim();

                while (folderPath.length > 0) {
                    const folder = this.folders.get(folderPath);
                    if (folder) folder.setAsOpenedOnInit();

                    const lastSlashIndex = folderPath.lastIndexOf("/");
                    if (lastSlashIndex === -1) {
                        folderPath = "";
                    } else {
                        folderPath = folderPath.substring(0, lastSlashIndex);
                    }
                }

                continue;
            }

            // CODE HIGLHLIGHT COMMAND
            if (commandElement.dataset.commandCodeHighlight !== undefined) {
                const filePath = commandElement.innerText.trim();
                const code = commandElement.dataset.commandCodeHighlight;

                const codeElements = this.getCodeElementsByPath(filePath);

                codeElements.forEach(codeElement => {
                    (codeElement as HTMLElement).dataset.codeHighlight = code;
                });

                continue;
            }

            // SET ACTIVE FILE COMMAND
            if (commandElement.dataset.commandSetActiveFile !== undefined) {
                const filePath = commandElement.innerText.trim();

                const codeElements = this.getCodeElementsByPath(filePath);

                codeElements.forEach(codeElement => {
                    (codeElement as HTMLElement).dataset.active = "";
                });

                continue;
            }

            // CREATE FOLDER COMMAND
            if (commandElement.dataset.commandCreateFolder !== undefined) {
                const path = commandElement.innerText.trim();
                const names = path.split("/");

                const folderNames = [];
                let prevFolder = this.rootFolder;
                for (let name of names) {
                    folderNames.push(name);

                    const folderPath = folderNames.join("/");
                    let folder = this.folders.get(folderPath);
                    if (!folder) {
                        folder = CollapsibleContainerFactory.createFolder(name, folderPath, this.projectId);
                        folder.appendToElement(prevFolder.collapsibleElement);
                        this.folders.set(folderPath, folder);
                    }

                    prevFolder = folder;
                }
            }

            // SET JAVA PACKAGES FOLDER COMMAND
            if (commandElement.dataset.commandSetJavaPackagesFolder !== undefined) {
                this.javaPackagesFolderPath = commandElement.innerText.trim();
            }
        }
    }

    /**
     * Processes commands after initialization of code box.
     */
    private processCommandsAfterInit() : void {
        const commandElementsContainer = this.codeBoxElement.querySelector("[data-project-commands]");
        if (!commandElementsContainer) return;

        const openJavaPackageCommandElements = commandElementsContainer.querySelectorAll("[data-command-open-java-package]");

        openJavaPackageCommandElements.forEach(commandElement => {
            // OPEN JAVA PACKAGE COMMAND
            let javaPackageName = (commandElement as HTMLElement).innerText.trim();

            if (javaPackageName.length === 0) {
                if (this.defaultJavaPackage) this.defaultJavaPackage.setAsOpenedOnInit();
            } else {
                const javaPackage = this.javaPackages.get(javaPackageName);
                if (javaPackage) javaPackage.setAsOpenedOnInit();
            }
        });
    }

    /**
     * Removes configuration elements after initialization of code box.
     */
    private removeConfigurationElements() {
        const commandElementsContainer = this.codeBoxElement.querySelector("[data-project-commands]");
        const foldersElement = this.codeBoxElement.querySelector("[data-project-folders]");

        if (commandElementsContainer) commandElementsContainer.remove();
        if (foldersElement) foldersElement.remove();
    }

    /**
     * Finds code elements in code box based on passed file path.
     * @param path Path of file (code).
     * @returns Code elements.
     */
    private getCodeElementsByPath(path: string) : NodeListOf<Element> {
        const names = path.split("/");
        const fileName = names.pop();
        const folderPath = names.join("/");

        let querySelector: string;
        if (folderPath) {
            querySelector = `[data-folder="${folderPath}"][data-code="${fileName}"]`;
        } else {
            querySelector = `:not([data-folder])[data-code="${fileName}"],[data-folder=""][data-code="${fileName}"]`;
        }
        if (
            this.javaPackagesFolderPath !== null
            && folderPath.startsWith(this.javaPackagesFolderPath)
            && !(folderPath.length > this.javaPackagesFolderPath.length && folderPath.charAt(this.javaPackagesFolderPath.length) !== "/")
        ) {
            const javaPackagesPathFolderNames = this.javaPackagesFolderPath.split("/");
            const folderNames = [];

            for (let i = javaPackagesPathFolderNames.length; i < names.length; i++) {
                folderNames.push(names[i]);
            }

            if (folderNames.length > 0) {
                querySelector += `,[data-java-package="${folderNames.join(".")}"][data-code="${fileName}"]`;
            } else {
                querySelector += `,[data-java-package=""][data-code="${fileName}"]`;
            }
        } else {
            if (!folderPath && this.javaPackagesFolderPath !== null && this.javaPackagesFolderPath !== "") {
                querySelector = ":not([data-java-package])" + querySelector + ":not([data-java-package])";
            }
        }

        return this.codeBoxElement.querySelectorAll(querySelector);
    }

    /**
     * Finds file elements in code box based on passed file path.
     * @param path Path of file.
     * @returns File elements.
     */
    private getFileElementsByPath(path: string) : Element[] {
        const names = path.split("/");
        names.pop();
        const folderPath = names.join("/");

        let querySelector: string;
        if (folderPath) {
            querySelector = `[data-file][data-folder="${folderPath}"]`;
        } else {
            querySelector = `[data-file]`;
        }

        const fileElements = this.codeBoxElement.querySelectorAll(querySelector);

        const result = new Array<Element>();

        fileElements.forEach(fileElement => {
            let fileElementFilePath;
            if ((fileElement as HTMLElement).dataset.folder) {
                fileElementFilePath = (fileElement as HTMLElement).dataset.folder + "/" + ((fileElement as HTMLElement).innerText || "unnamed");
            } else {
                fileElementFilePath = ((fileElement as HTMLElement).innerText || "unnamed");
            }

            if (fileElementFilePath === path) {
                result.push(fileElement);
            }
        });

        return result;
    }

    /**
     * Returns all file elements of code box.
     * @returns File elements.
     */
    private getFileElements() : NodeListOf<Element> {
        return this.codeBoxElement.querySelectorAll("[data-file]");
    }

    /**
     * Returns initialization folder structure that can be used in different code box to generate folders.
     * @returns Initialization folder structure of code box.
     */
    private getInitFolderStructure(): TreeNode<string>[] {
        const tree = new TreeNode<string>("root");

        this.folders.forEach((_, folderPath) => {
            // skip folders that were auto generated
            if (this.autoGeneratedFolders.has(folderPath)) return;

            const folderNames = folderPath.split("/");

            let prevNode = tree;
            for (let folderName of folderNames) {
                let node = prevNode.findChildrenByValue(folderName);
                if (!node) {
                    node = new TreeNode<string>(folderName);
                    prevNode.addChildren(node);
                }
                prevNode = node;
            }
        });

        return tree.children;
    }

    /**
     * Returns project ID found in data attribute of code box element.
     * @returns Project ID.
     */
    private getProjectIdFromDataAttribute() : string {
        const projectId = this.codeBoxElement.dataset.project;
        if (!projectId) {
            throw new Error("No project ID assigned.");
        }
        if (ProjectCodeBox.occupiedProjectIds.has(projectId)) {
            throw new Error("Project with this ID already exists.");
        }
        ProjectCodeBox.occupiedProjectIds.set(projectId, true);
        return projectId;
    }

    /**
     * Sorts folders in code box panel.
     */
    private sortFolders() {
        this.rootFolder.sortChildFolders();
        this.folders.forEach(folder => folder.sortChildFolders());
    }

    /**
     * Sorts file buttons in code box panel.
     */
    private sortFileButtons() : void {
        this.rootFolder.sortFileButtons();
        this.folders.forEach(folder => folder.sortFileButtons());
        this.defaultJavaPackage?.sortFileButtons();
        this.javaPackages.forEach(javaPackage => javaPackage.sortFileButtons());
    }

    /**
     * Sorts java packages in code box panel.
     */
    private sortJavaPackages() : void {
        const javaPackages: CollapsibleContainer[] = [];
        this.javaPackages.forEach(javaPackage => {
            javaPackages.push(javaPackage);
        });

        javaPackages.sort((a, b) => {
            if (a.name < b.name) return -1;
            if (a.name == b.name) return 0;
            return 1;
        });

        for (let javaPackage of javaPackages) {
            this.panelContentElement.appendChild(javaPackage.buttonElement);
            this.panelContentElement.appendChild(javaPackage.collapsibleElement);
        }
    }

    /**
     * Creates toggle button for code box panel.
     * @returns Code box panel toggle button.
     */
    private createPanelToggleButton() : HTMLButtonElement {
        const button = document.createElement("button");
        button.classList.add(ProjectCodeBox.CSS_PANEL_TOGGLE_BUTTON_CLASS);
        button.innerHTML = `
        ${ProjectCodeBox.PANEL_TOGGLE_BUTTON_TEXT}
        ${SVGIconElementCreator.create(ProjectCodeBox.PANEL_TOGGLE_BUTTON_ICON_NAME)}
        `;
        this.panelElement.appendChild(button);

        return button;
    }

    /**
     * Creates folder structure in code box panel based on ul element in code box marked with data-project-folders attribute.
     * @param rootCollapsible Root collapsible container into which should be added collapsible containers for folder.
     */
    private createFoldersStructure(rootCollapsible : CollapsibleContainer) : void {
        const foldersElement = this.codeBoxElement.querySelector("[data-project-folders]");
        if (!foldersElement) return;

        this.createFoldersStructureTraverse(foldersElement as HTMLElement, rootCollapsible);
    }

    /**
     * Helper method for createFoldersStructure method.
     * @param ulElement UL element.
     * @param parentCollapsible Parent collapsible.
     * @param parentFolderNames Array of parent folder names.
     */
    private createFoldersStructureTraverse(ulElement: HTMLElement, parentCollapsible: CollapsibleContainer, parentFolderNames: string[] = []) {
        // for each li element in ul element
        for (let i = 0; i < ulElement.children.length; i++) {
            let child = ulElement.children[i];
            if (child.tagName !== "LI") continue;

            let folderName;
            let childUlElement;
            // determine folder name and child ul element of li element
            child.childNodes.forEach(node => {
                if (node instanceof Text) {
                    let text = node.textContent?.trim();

                    if (text && text.length > 0) {
                        folderName = text;
                    }
                } else if (node instanceof Element && node.tagName === "UL") {
                    childUlElement = node;
                }
            });
            if (folderName) {
                // determine path to folder
                const folderPath = [...parentFolderNames, folderName].join("/");

                let openedOnInit = child instanceof HTMLElement && child.hasAttribute("data-opened");
                // create collapsible container for folder
                const folderCollapsible = CollapsibleContainerFactory.createFolder(folderName, folderPath, this.projectId, openedOnInit);
                folderCollapsible.appendToElement(parentCollapsible.collapsibleElement);

                this.folders.set(folderPath, folderCollapsible);

                // if folder is set as java packages folder
                if (child.hasAttribute("data-java-packages-folder")) {
                    this.javaPackagesFolderPath = folderPath;
                }

                // traverse child folders of folder
                if (childUlElement) {
                    this.createFoldersStructureTraverse(childUlElement, folderCollapsible, [...parentFolderNames, folderName]);
                }
            }
        }
    }

    /**
     * Creates folder structure in code box panel based on folders tree.
     * @param folders Folders tree.
     * @param parentCollapsible Collapsible container in which should be created folder structure.
     * @param parentFolderNames Array of parent folder names.
     */
    private createFoldersStructureFromFoldersTree(folders: TreeNode<string>[], parentCollapsible: CollapsibleContainer, parentFolderNames: string[] = []) : void {
        for (let node of folders) {
            const folderName = node.value;
            const folderPath = [...parentFolderNames, folderName].join("/");

            const folderCollapsible = CollapsibleContainerFactory.createFolder(node.value, folderPath, this.projectId);
            folderCollapsible.appendToElement(parentCollapsible.collapsibleElement);

            this.folders.set(folderPath, folderCollapsible);

            if (node.children.length > 0) {
                this.createFoldersStructureFromFoldersTree(node.children, folderCollapsible, [...parentFolderNames, folderName]);
            }
        }
    }
}

export default ProjectCodeBox;