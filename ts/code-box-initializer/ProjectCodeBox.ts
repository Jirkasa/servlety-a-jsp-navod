import CodeBox from "./CodeBox";
import CodeBoxCode from "./CodeBoxCode";
import CodeButton from "./CodeButton";
import CollapsibleContainer from "./CollapsibleContainer";
import CollapsibleContainerFactory from "./CollapsibleContainerFactory";
import MultiProjectCodeButton from "./MultiProjectCodeButton";
import ProjectCodeButton from "./ProjectCodeButton";
import SVGIconElementCreator from "./SVGIconElementCreator";
import TreeNode from "./TreeNode";

class ProjectCodeBox extends CodeBox {
    private static readonly CSS_CODE_BOX_MODIFIER_CLASS = "code-box--project";
    private static readonly CSS_PANEL_CLASS = "code-box-project-panel";
    private static readonly CSS_PANEL_OPENED_MODIFIER_CLASS = "code-box-project-panel--opened";
    private static readonly CSS_PANEL_CONTENT_CLASS = "code-box-project-panel__content";
    private static readonly CSS_PANEL_TOGGLE_BUTTON_CLASS = "code-box-project-panel__toggle-button";
    private static readonly CSS_PANEL_TOGGLE_BUTTON_OPENED_MODIFIER_CLASS = "code-box-project-panel__toggle-button--opened";
    private static readonly CSS_PANEL_HEADING_CLASS = "code-box-project-panel__heading";
    private static readonly CSS_PANEL_HORIZONTAL_RULE_CLASS = "code-box-project-panel__horizontal-rule";

    private static readonly PANEL_TOGGLE_BUTTON_ICON_NAME = "double-arrow-right";

    private static readonly PANEL_TOGGLE_BUTTON_TEXT = "Otevří/Zavřít boční panel";

    private static readonly occupiedProjectIds : Map<string, boolean> = new Map();

    private projectId : string;

    private rootFolder : CollapsibleContainer;
    private folders : Map<string, CollapsibleContainer>;
    private defaultJavaPackage : CollapsibleContainer | null;
    private javaPackages : Map<string, CollapsibleContainer>;

    private javaPackagesFolderPath: string | null;

    private autoGeneratedFolders : Map<string, boolean>;
    private usedFilePaths: Map<string, boolean>;
    private usedJavaPackagePaths: Map<string, boolean>; // todo - je to ve formátu io.github.jirkasa.NazevSouboru

    private panelElement : HTMLElement;
    private panelContentElement : HTMLElement;
    private panelToggleButton : HTMLButtonElement;

    constructor(codeBoxElement: HTMLElement, parentCodeBox: ProjectCodeBox | null = null) {
        super(codeBoxElement, true);

        this.projectId = this.getProjectIdFromDataAttribute();

        this.folders = new Map();
        this.javaPackages = new Map();
        this.defaultJavaPackage = null;

        this.javaPackagesFolderPath = null;

        this.autoGeneratedFolders = new Map();
        this.usedFilePaths = new Map();
        this.usedJavaPackagePaths = new Map();

        codeBoxElement.classList.add(ProjectCodeBox.CSS_CODE_BOX_MODIFIER_CLASS);

        this.panelElement = document.createElement("div");
        this.panelElement.classList.add(ProjectCodeBox.CSS_PANEL_CLASS);
        codeBoxElement.appendChild(this.panelElement);

        this.panelContentElement = document.createElement("div");
        this.panelContentElement.classList.add(ProjectCodeBox.CSS_PANEL_CONTENT_CLASS);
        this.panelElement.appendChild(this.panelContentElement);

        this.panelToggleButton = this.createPanelToggleButton();
        this.panelToggleButton.addEventListener("click", () => this.onPanelToggleButtonClick());

        const folderStructureHeading = document.createElement("h3");
        folderStructureHeading.classList.add(ProjectCodeBox.CSS_PANEL_HEADING_CLASS);
        folderStructureHeading.innerText = "Adresářová struktura";
        this.panelContentElement.appendChild(folderStructureHeading);

        if (parentCodeBox) {
            this.rootFolder = CollapsibleContainerFactory.createProjectRoot(parentCodeBox.getProjectName(), this.projectId);
            this.rootFolder.appendToElement(this.panelContentElement);
            this.createFoldersStructureFromFoldersTree(parentCodeBox.getInitFolderStructure(), this.rootFolder);
            this.javaPackagesFolderPath = parentCodeBox.javaPackagesFolderPath;
        } else {
            this.rootFolder = CollapsibleContainerFactory.createProjectRoot(codeBoxElement.dataset.projectName || "unnamed", this.projectId);
            this.rootFolder.appendToElement(this.panelContentElement);
            this.createFoldersStructure(this.rootFolder);
        }

        const horizontalRule = document.createElement("hr");
        horizontalRule.classList.add(ProjectCodeBox.CSS_PANEL_HORIZONTAL_RULE_CLASS);
        this.panelContentElement.appendChild(horizontalRule);

        const javaPackagesHeading = document.createElement("h3");
        javaPackagesHeading.classList.add(ProjectCodeBox.CSS_PANEL_HEADING_CLASS);
        javaPackagesHeading.innerText = "Java balíčky";
        this.panelContentElement.appendChild(javaPackagesHeading);

        if (parentCodeBox) {
            for (let code of parentCodeBox.codes) {
                const codeElement = code.cloneCodeElement();
                codeBoxElement.appendChild(codeElement);
            }
        }

        this.processCommands();

        this.init();

        this.sortJavaPackages();
        this.sortFolders();
        this.sortFileButtons();

        if (this.javaPackages.size === 0 && !this.defaultJavaPackage) {
            horizontalRule.remove();
            javaPackagesHeading.remove();
        }

        this.processCommandsAfterInit();
    }

    public getProjectName() : string {
        return this.rootFolder.name;
    }

    private onPanelToggleButtonClick() : void {
        this.panelToggleButton.classList.toggle(ProjectCodeBox.CSS_PANEL_TOGGLE_BUTTON_OPENED_MODIFIER_CLASS);
        this.panelElement.classList.toggle(ProjectCodeBox.CSS_PANEL_OPENED_MODIFIER_CLASS);
    }

    protected onDisplayedCodeChanged(): void {
        this.panelToggleButton.classList.remove(ProjectCodeBox.CSS_PANEL_TOGGLE_BUTTON_OPENED_MODIFIER_CLASS);
        this.panelElement.classList.remove(ProjectCodeBox.CSS_PANEL_OPENED_MODIFIER_CLASS);
    }

    protected validateCodeElement(codeElement: HTMLElement): boolean {
        let isValid = true;

        let filePath;
        if (this.javaPackagesFolderPath !== null && codeElement.dataset.folder === undefined && codeElement.dataset.javaPackage !== undefined) {
            const javaPackage = codeElement.dataset.javaPackage?.trim();
            if (javaPackage) {
                filePath = this.javaPackagesFolderPath + "/" + javaPackage.replace(/\./g, "/") + "/" + (codeElement.dataset.code || "unnamed");
            } else {
                filePath = this.javaPackagesFolderPath + "/" + (codeElement.dataset.code || "unnamed");
            }
        } else {
            let pathArr: string[];
            pathArr = codeElement.dataset.folder?.split("/") || [];
            pathArr = pathArr.filter(folderName => folderName.trim().length > 0);
            pathArr.push(codeElement.dataset.code || "unnamed");
            filePath = pathArr.join("/");
        }

        if (this.usedFilePaths.has(filePath)) {
            isValid = false;
        } else {
            this.usedFilePaths.set(filePath, true);
        }

        if (codeElement.dataset.javaPackage !== undefined) {
            let javaPackagePath = codeElement.dataset.javaPackage.trim();
            if (javaPackagePath.length > 0) {
                javaPackagePath += ".";
            }
            javaPackagePath += codeElement.dataset.code || "unnamed";

            if (this.usedJavaPackagePaths.has(javaPackagePath)) {
                isValid = false;
            } else {
                this.usedJavaPackagePaths.set(javaPackagePath, true);
            }
        }
        
        return isValid;
    }

    protected createCodeButton(codeBoxCode: CodeBoxCode, codeElementDataset: DOMStringMap): CodeButton {
        let folderPath = codeElementDataset.folder;
        const javaPackage = codeElementDataset.javaPackage?.trim();
        const fileName = codeElementDataset.code;

        let javaPackageCollapsible;
        if (javaPackage !== undefined) {
            if (javaPackage.length > 0) {
                javaPackageCollapsible = this.javaPackages.get(javaPackage);
                if (!javaPackageCollapsible) {
                    javaPackageCollapsible = CollapsibleContainerFactory.createJavaPackage(javaPackage, this.projectId);
                    javaPackageCollapsible.appendToElement(this.panelContentElement);
                    this.javaPackages.set(javaPackage, javaPackageCollapsible);
                }
            } else {
                javaPackageCollapsible = this.defaultJavaPackage;
                if (!javaPackageCollapsible) {
                    javaPackageCollapsible = CollapsibleContainerFactory.createDefaultJavaPackage(this.projectId);
                    javaPackageCollapsible.appendToElement(this.panelContentElement);
                    this.defaultJavaPackage = javaPackageCollapsible;
                }
            }
            
            if (codeElementDataset.javaPackageOpened !== undefined) {
                javaPackageCollapsible.setAsOpenedOnInit();
            }

            if (folderPath === undefined && this.javaPackagesFolderPath) {
                const folderNames = javaPackage.split(".");

                folderPath = this.javaPackagesFolderPath;
                let previousFolder = this.folders.get(folderPath);
                if (previousFolder) {
                    for (let folderName of folderNames) {
                        if (folderName.trim().length === 0) continue;
                        folderPath += `/${folderName.trim()}`;
                        
                        let folder = this.folders.get(folderPath);
                        if (!folder) {
                            folder = CollapsibleContainerFactory.createFolder(folderName.trim(), folderPath, this.projectId);
                            folder.appendToElement(previousFolder.collapsibleElement);
                            this.folders.set(folderPath, folder);

                            this.autoGeneratedFolders.set(folderPath, true);
                        }

                        previousFolder = folder;
                    }
                }
            }
        }

        let folderCollapsible;
        if (folderPath) {
            folderCollapsible = this.folders.get(folderPath);
            if (!folderCollapsible) folderCollapsible = this.rootFolder;
        } else {
            folderCollapsible = this.rootFolder;
        }

        if (javaPackageCollapsible) {
            return new MultiProjectCodeButton(fileName || "unnamed", [folderCollapsible.collapsibleElement, javaPackageCollapsible.collapsibleElement], codeBoxCode);
        } else {
            return new ProjectCodeButton(fileName || "unnamed", folderCollapsible.collapsibleElement, codeBoxCode);
        }
    }

    private processCommands() : void {
        const commandElementsContainer = this.codeBoxElement.querySelector("[data-project-commands]");
        if (!commandElementsContainer) return;

        for (let i = 0; i < commandElementsContainer.children.length; i++) {
            const commandElement = commandElementsContainer.children[i] as HTMLElement;

            // REMOVE FOLDER COMMAND
            if (commandElement.dataset.commandRemoveFolder !== undefined) {
                const folderPath = commandElement.innerText.trim();

                // ještě to nebere soubory, u kterých se folder nenastavuje - ty co mají folder podle balíčku
                let querySelector: string;
                if (this.javaPackagesFolderPath !== null && (folderPath.startsWith(this.javaPackagesFolderPath) || this.javaPackagesFolderPath.startsWith(folderPath))) {
                    querySelector = `[data-folder^="${folderPath}"], [data-java-package]`;
                } else {
                    querySelector = `[data-folder^="${folderPath}"]`;
                }
                const codeElements = this.codeBoxElement.querySelectorAll(querySelector);
                codeElements.forEach(codeElement => {
                    let codeElementFolderPath = (codeElement as HTMLElement).dataset.folder;
                    if (codeElementFolderPath === undefined) {
                        let javaPackage = (codeElement as HTMLElement).dataset.javaPackage;
                        if (javaPackage === undefined) return;

                        if (this.javaPackagesFolderPath) {
                            codeElementFolderPath = this.javaPackagesFolderPath + "/" + javaPackage.replace(/\./g, "/");
                        } else {
                            codeElementFolderPath = "";
                        }
                    }

                    // if code is located in different folder that just starts with folderPath
                    if (codeElementFolderPath.length > folderPath.length && codeElementFolderPath.charAt(folderPath.length) !== "/") return;
                    if (codeElementFolderPath.length < folderPath.length) return;
                    
                    codeElement.remove();
                });

                const folderPathsToDelete: string[] = [];
                this.folders.forEach((_, path) => {
                    if (path.startsWith(folderPath)) {
                        if (path.length > folderPath.length && path.charAt(folderPath.length) !== "/") return;
                        folderPathsToDelete.push(path);
                    }
                });

                for (let path of folderPathsToDelete) {
                    const folderCollapsible = this.folders.get(path);
                    folderCollapsible?.detachFromElement();
                    this.folders.delete(path);
                }

                continue;
            }

            // REMOVE FILE COMMAND
            if (commandElement.dataset.commandRemoveFile !== undefined) {
                const filePath = commandElement.innerText.trim();

                let querySelector: string;
                if (!filePath.includes("/")) {
                    querySelector = `[data-code="${filePath}"]`;
                } else if (this.javaPackagesFolderPath !== null && filePath.startsWith(this.javaPackagesFolderPath)) {
                    querySelector = `[data-folder^="${filePath}"], [data-java-package]`;
                } else {
                    querySelector = `[data-folder^="${filePath}"]`;
                }
                const codeElements = this.codeBoxElement.querySelectorAll(querySelector);

                codeElements.forEach(codeElement => {
                    let codeElementFilePath;
                    if ((codeElement as HTMLElement).dataset.folder === undefined && (codeElement as HTMLElement).dataset.javaPackage !== undefined) {
                        let javaPackage = (codeElement as HTMLElement).dataset.javaPackage;
                        if (javaPackage === undefined) return;

                        if (this.javaPackagesFolderPath) {
                            if (javaPackage.length > 0) {
                                codeElementFilePath = this.javaPackagesFolderPath + "/" + javaPackage.replace(/\./g, "/") + "/" + ((codeElement as HTMLElement).dataset.code || "unnamed");
                            } else {
                                codeElementFilePath = this.javaPackagesFolderPath + "/" + ((codeElement as HTMLElement).dataset.code || "unnamed");
                            }
                        } else {
                            codeElementFilePath = ((codeElement as HTMLElement).dataset.code || "unnamed");
                        }
                    } else {
                        if ((codeElement as HTMLElement).dataset.folder) {
                            codeElementFilePath = (codeElement as HTMLElement).dataset.folder + "/" + ((codeElement as HTMLElement).dataset.code || "unnamed");
                        } else {
                            codeElementFilePath = ((codeElement as HTMLElement).dataset.code || "unnamed");
                        }
                    }

                    if (codeElementFilePath === filePath) {
                        codeElement.remove();
                    }
                });

                continue;
            }

            // RENAME FOLDER COMMAND
            if (commandElement.dataset.commandRenameFolder !== undefined) {
                const folderPath = commandElement.innerText.trim();
                const newFolderName = commandElement.dataset.commandRenameFolder.trim();
                let startIndex: number;
                if (folderPath.includes("/")) {
                    startIndex = folderPath.lastIndexOf("/") + 1;
                } else {
                    startIndex = 0;
                }

                if (newFolderName.length === 0) continue;

                if (this.javaPackagesFolderPath !== null && this.javaPackagesFolderPath.startsWith(folderPath)) {
                    let endIndex = this.javaPackagesFolderPath.indexOf("/", startIndex + 1);
                    if (endIndex === -1) {
                        endIndex = this.javaPackagesFolderPath.length;
                    }

                    this.javaPackagesFolderPath = this.javaPackagesFolderPath.substring(0, startIndex) + newFolderName + this.javaPackagesFolderPath.substring(endIndex, this.javaPackagesFolderPath.length);
                }

                const folderPathsToRename: {oldPath: string, newPath: string}[] = [];
                this.folders.forEach((_, path) => {
                    if (!path.startsWith(folderPath)) return;
                    if (path.length > folderPath.length && path.charAt(folderPath.length) !== "/") return;

                    let endIndex = path.indexOf("/", startIndex + 1);
                    if (endIndex === -1) {
                        endIndex = path.length;
                    }

                    folderPathsToRename.push({
                        oldPath: path,
                        newPath: path.substring(0, startIndex) + newFolderName + path.substring(endIndex, path.length)
                    });
                });

                for (let folder of folderPathsToRename) {
                    const folderCollapsible = this.folders.get(folder.oldPath);
                    this.folders.delete(folder.oldPath);
                    if (folderCollapsible) {
                        if (folder.oldPath === folderPath) {
                            folderCollapsible.name = newFolderName;
                        }
                        this.folders.set(folder.newPath, folderCollapsible);
                    }
                }

                const codeElements = document.querySelectorAll(`[data-folder^="${folderPath}"]`);
                codeElements.forEach(codeElement => {
                    let path = (codeElement as HTMLElement).dataset.folder;
                    if (path === undefined) return;
                    if (!path.startsWith(folderPath)) return;
                    if (path.length > folderPath.length && path.charAt(folderPath.length) !== "/") return;

                    let endIndex = path.indexOf("/", startIndex + 1);
                    if (endIndex === -1) {
                        endIndex = path.length;
                    }

                    (codeElement as HTMLElement).dataset.folder = path.substring(0, startIndex) + newFolderName + path.substring(endIndex, path.length);
                });

                continue;
            }

            // RENAME FILE COMMAND
            if (commandElement.dataset.commandRenameFile !== undefined) {
                const filePath = commandElement.innerText.trim();
                const newName = commandElement.dataset.commandRenameFile.trim();
                if (newName.length === 0) continue;

                const codeElements = this.getCodeElementsByPath(filePath);

                codeElements.forEach(codeElement => {
                    (codeElement as HTMLElement).dataset.code = newName;
                });

                continue;
            }

            // OPEN FOLDER COMMAND
            if (commandElement.dataset.commandOpenFolder !== undefined) {
                const folderPath = commandElement.innerText.trim();

                const folder = this.folders.get(folderPath);
                if (!folder) continue;

                folder.setAsOpenedOnInit();

                continue;
            }

            // OPEN FOLDER TO ROOT COMMAND
            if (commandElement.dataset.commandOpenFolderToRoot !== undefined) {
                let folderPath = commandElement.innerText.trim();

                while (folderPath.length > 0) {
                    const folder = this.folders.get(folderPath);
                    if (folder) folder.setAsOpenedOnInit();

                    const lastSlashIndex = folderPath.lastIndexOf("/");
                    if (lastSlashIndex === -1) {
                        folderPath = "";
                    } else {
                        folderPath = folderPath.substring(0, lastSlashIndex);
                    }
                }

                continue;
            }

            // CODE HIGLHLIGHT COMMAND
            if (commandElement.dataset.commandCodeHighlight !== undefined) {
                const filePath = commandElement.innerText.trim();
                const code = commandElement.dataset.commandCodeHighlight;

                const codeElements = this.getCodeElementsByPath(filePath);

                codeElements.forEach(codeElement => {
                    (codeElement as HTMLElement).dataset.codeHighlight = code;
                });

                continue;
            }

            // SET ACTIVE FILE COMMAND
            if (commandElement.dataset.commandSetActiveFile !== undefined) {
                const filePath = commandElement.innerText.trim();

                const codeElements = this.getCodeElementsByPath(filePath);

                codeElements.forEach(codeElement => {
                    (codeElement as HTMLElement).dataset.active = "";
                });

                continue;
            }

            // CREATE FOLDER COMMAND
            if (commandElement.dataset.commandCreateFolder !== undefined) {
                const path = commandElement.innerText.trim();
                const names = path.split("/");

                const folderNames = [];
                let prevFolder = this.rootFolder;
                for (let name of names) {
                    folderNames.push(name);

                    const folderPath = folderNames.join("/");
                    let folder = this.folders.get(folderPath);
                    if (!folder) {
                        folder = CollapsibleContainerFactory.createFolder(name, folderPath, this.projectId);
                        folder.appendToElement(prevFolder.collapsibleElement);
                        this.folders.set(folderPath, folder);
                    }

                    prevFolder = folder;
                }
            }

            // SET JAVA PACKAGES FOLDER COMMAND
            if (commandElement.dataset.commandSetJavaPackagesFolder !== undefined) {
                this.javaPackagesFolderPath = commandElement.innerText.trim();
            }
        }
    }

    private processCommandsAfterInit() : void {
        const commandElementsContainer = this.codeBoxElement.querySelector("[data-project-commands]");
        if (!commandElementsContainer) return;

        const openJavaPackageCommandElements = commandElementsContainer.querySelectorAll("[data-command-open-java-package]");

        openJavaPackageCommandElements.forEach(commandElement => {
            // OPEN JAVA PACKAGE COMMAND
            let javaPackageName = (commandElement as HTMLElement).innerText.trim();

            if (javaPackageName.length === 0) {
                if (this.defaultJavaPackage) this.defaultJavaPackage.setAsOpenedOnInit();
            } else {
                const javaPackage = this.javaPackages.get(javaPackageName);
                if (javaPackage) javaPackage.setAsOpenedOnInit();
            }
        });
    }

    private getCodeElementsByPath(path: string) : NodeListOf<Element> {
        const names = path.split("/");
        const fileName = names.pop();
        const folderPath = names.join("/");

        let querySelector: string;
        if (folderPath) {
            querySelector = `[data-folder="${folderPath}"][data-code="${fileName}"]`;
        } else {
            querySelector = `:not([data-folder])[data-code="${fileName}"],[data-folder=""][data-code="${fileName}"]`;
        }
        if (
            this.javaPackagesFolderPath !== null
            && folderPath.startsWith(this.javaPackagesFolderPath)
            && !(folderPath.length > this.javaPackagesFolderPath.length && folderPath.charAt(this.javaPackagesFolderPath.length) !== "/")
        ) {
            const javaPackagesPathFolderNames = this.javaPackagesFolderPath.split("/");
            const folderNames = [];

            for (let i = javaPackagesPathFolderNames.length; i < names.length; i++) {
                folderNames.push(names[i]);
            }

            if (folderNames.length > 0) {
                querySelector += `,[data-java-package="${folderNames.join(".")}"][data-code="${fileName}"]`;
            } else {
                querySelector += `,[data-java-package=""][data-code="${fileName}"]`;
            }
        } else {
            if (!folderPath && this.javaPackagesFolderPath !== null && this.javaPackagesFolderPath !== "") {
                querySelector = ":not([data-java-package])" + querySelector + ":not([data-java-package])";
            }
        }

        return document.querySelectorAll(querySelector);
    }

    private getInitFolderStructure(): TreeNode<string>[] {
        const tree = new TreeNode<string>("root");

        this.folders.forEach((_, folderPath) => {
            if (this.autoGeneratedFolders.has(folderPath)) return;

            const folderNames = folderPath.split("/");

            let prevNode = tree;
            for (let folderName of folderNames) {
                let node = prevNode.findChildrenByValue(folderName);
                if (!node) {
                    node = new TreeNode<string>(folderName);
                    prevNode.addChildren(node);
                }
                prevNode = node;
            }
        });

        return tree.children;
    }

    private getProjectIdFromDataAttribute() : string {
        const projectId = this.codeBoxElement.dataset.project;
        if (!projectId) {
            throw new Error("No project ID assigned.");
        }
        if (ProjectCodeBox.occupiedProjectIds.has(projectId)) {
            throw new Error("Project with this ID already exists.");
        }
        ProjectCodeBox.occupiedProjectIds.set(projectId, true);
        return projectId;
    }

    private sortFolders() {
        this.rootFolder.sortChildFolders();
        this.folders.forEach(folder => folder.sortChildFolders());
    }

    private sortFileButtons() : void {
        this.rootFolder.sortFileButtons();
        this.folders.forEach(folder => folder.sortFileButtons());
        this.defaultJavaPackage?.sortFileButtons();
        this.javaPackages.forEach(javaPackage => javaPackage.sortFileButtons());
    }

    private sortJavaPackages() : void {
        const javaPackages: CollapsibleContainer[] = [];
        this.javaPackages.forEach(javaPackage => {
            javaPackages.push(javaPackage);
        });

        javaPackages.sort((a, b) => {
            if (a.name < b.name) return -1;
            if (a.name == b.name) return 0;
            return 1;
        });

        for (let javaPackage of javaPackages) {
            this.panelContentElement.appendChild(javaPackage.buttonElement);
            this.panelContentElement.appendChild(javaPackage.collapsibleElement);
        }
    }

    private createPanelToggleButton() : HTMLButtonElement {
        const button = document.createElement("button");
        button.classList.add(ProjectCodeBox.CSS_PANEL_TOGGLE_BUTTON_CLASS);
        button.innerHTML = `
        ${ProjectCodeBox.PANEL_TOGGLE_BUTTON_TEXT}
        ${SVGIconElementCreator.create(ProjectCodeBox.PANEL_TOGGLE_BUTTON_ICON_NAME)}
        `;
        this.panelElement.appendChild(button);

        return button;
    }

    private createFoldersStructure(rootCollapsible : CollapsibleContainer) : void {
        const foldersElement = this.codeBoxElement.querySelector("[data-project-folders]");
        if (!foldersElement) return;

        this.createFoldersStructureTraverse(foldersElement as HTMLElement, rootCollapsible);
        foldersElement.remove();
    }

    private createFoldersStructureTraverse(ulElement: HTMLElement, parentCollapsible: CollapsibleContainer, parentFolderNames: string[] = []) { // todo - přejmenovat
        for (let i = 0; i < ulElement.children.length; i++) {
            let child = ulElement.children[i];

            if (child.tagName !== "LI") continue;

            let folderName;
            let childUlElement;
            child.childNodes.forEach(node => {
                if (node instanceof Text) {
                    let text = node.textContent?.trim();

                    if (text && text.length > 0) {
                        folderName = text;
                    }
                } else if (node instanceof Element && node.tagName === "UL") {
                    childUlElement = node;
                }
            });
            if (folderName) {
                const folderPath = [...parentFolderNames, folderName].join("/");

                let openedOnInit = child instanceof HTMLElement && child.hasAttribute("data-opened");
                const folderCollapsible = CollapsibleContainerFactory.createFolder(folderName, folderPath, this.projectId, openedOnInit);
                folderCollapsible.appendToElement(parentCollapsible.collapsibleElement);

                this.folders.set(folderPath, folderCollapsible);

                if (child.hasAttribute("data-java-packages-folder")) {
                    this.javaPackagesFolderPath = folderPath;
                }

                if (childUlElement) {
                    this.createFoldersStructureTraverse(childUlElement, folderCollapsible, [...parentFolderNames, folderName]);
                }
            }
        }
    }

    private createFoldersStructureFromFoldersTree(folders: TreeNode<string>[], parentCollapsible: CollapsibleContainer, parentFolderNames: string[] = []) : void {
        for (let node of folders) {
            const folderName = node.value;
            const folderPath = [...parentFolderNames, folderName].join("/");

            const folderCollapsible = CollapsibleContainerFactory.createFolder(node.value, folderPath, this.projectId);
            folderCollapsible.appendToElement(parentCollapsible.collapsibleElement);

            this.folders.set(folderPath, folderCollapsible);

            if (node.children.length > 0) {
                this.createFoldersStructureFromFoldersTree(node.children, folderCollapsible, [...parentFolderNames, folderName]);
            }
        }
    }
}

export default ProjectCodeBox;